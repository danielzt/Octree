//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;
public class Octree
{
	public OctreeData data;
	public byte[] trace;
	public delegate bool SplitPolicy(Vector3 coord,float length, byte[] trace);
	public Octree parent = null;
	SplitPolicy splitPolicy;
	public Vector3 position;
	public float boxLength;
	Octree[] child=null;

	public bool IsSplit {
		get{return (child != null);}
	}
	
	public Octree Child(int idx) {
		if(idx>7 || idx<0 || !this.IsSplit)
		{
			Debug.LogError("No children available or index is out of range");
			return null;
		}
		return child[idx];
	}



	public Octree (OctreeData data,Vector3 position,float length,byte[] trace)
	{
		this.trace = trace;
		this.position = position;
		this.data = data;
		this.boxLength = length;
	}

	public Octree (Octree parent,Vector3 position,float length,byte[] trace)
	{
		this.trace = trace;
		this.position = position;
		this.data = parent.data;
		this.boxLength = length;
		this.parent = parent;
	}

	public void Split()
	{
		if(data.splitPolicy(position,boxLength,trace))
		{
			float newLength = boxLength/2;
			int newTraceSize = trace.Length;
			List<byte> newTrace = new List<byte>(trace);
			newTrace.Add(0);
			child = new Octree[8];
			ArrayList threads = new ArrayList();
			for (byte i = 0; i < 8; i++) {
				newTrace[newTraceSize] = i;
				child[i] = new Octree(this,getChildPos(position,boxLength,i),newLength,newTrace.ToArray());

				lock(data._object){
					if(data.numThreads<data.threadLimit){
						Thread t = new Thread(new ThreadStart(child[i].Split));
						t.Start();
						threads.Add(t);
						data.numThreads++;
						continue;
					}
				}
				child[i].Split();

			}
			foreach(Thread t in threads)
			{
				t.Join ();
				lock(data._object){
					data.numThreads--;
				}
			}
		}
	}

	public static Vector3 getChildPos(Vector3 oldCenter, float oldLength, byte childNum)
	{
		Vector3 result;
		Vector3 diff;
		switch(childNum)
		{
		case 0:
			diff = -0.25f*new Vector3(oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 1:
			diff = 0.25f*new Vector3(oldLength,-oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 2:
			diff = 0.25f*new Vector3(oldLength,-oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 3:
			diff = 0.25f*new Vector3(-oldLength,-oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 4:
			diff = 0.25f*new Vector3(-oldLength,oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 5:
			diff = 0.25f*new Vector3(oldLength,oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 6:
			diff = 0.25f*new Vector3(oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 7:
			diff = 0.25f*new Vector3(-oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		default:
			Debug.LogError("Invalid child number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3 getCornerPos(Vector3 center, float length, byte cornerNum)
	{
		Vector3 result;
		Vector3 diff;
		switch(cornerNum)
		{
		case 0:
			diff = -0.5f*new Vector3(length,length,length);
			result = center + diff;
			break;
		case 1:
			diff = 0.5f*new Vector3(length,-length,-length);
			result = center + diff;
			break;
		case 2:
			diff = 0.5f*new Vector3(length,-length,length);
			result = center + diff;
			break;
		case 3:
			diff = 0.5f*new Vector3(-length,-length,length);
			result = center + diff;
			break;
		case 4:
			diff = 0.5f*new Vector3(-length,length,-length);
			result = center + diff;
			break;
		case 5:
			diff = 0.5f*new Vector3(length,length,-length);
			result = center + diff;
			break;
		case 6:
			diff = 0.5f*new Vector3(length,length,length);
			result = center + diff;
			break;
		case 7:
			diff = 0.5f*new Vector3(-length,length,length);
			result = center + diff;
			break;
		default:
			Debug.LogError("Invalid corner number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3[] GetCornersPos(Vector3 center, float length)
	{
		Vector3[] results = new Vector3[8];
		for (byte i = 0; i < 8; i++) {
			results[i] = getCornerPos(center,length,i);
		}
		return results;
	}

	public static Vector3 GetMidPointPos(Vector3 center, float length, byte posNum)
	{
		Vector3 result;
		Vector3 c0,c1;
		switch(posNum)
		{
		case 0:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,1);
			result = 0.5f*(c0+c1);
			break;
		case 1:
			c0 = getCornerPos(center,length,1);
			c1 = getCornerPos(center,length,2);
			result = 0.5f*(c0+c1);
			break;
		case 2:
			c0 = getCornerPos(center,length,2);
			c1 = getCornerPos(center,length,3);
			result = 0.5f*(c0+c1);
			break;
		case 3:
			c0 = getCornerPos(center,length,3);
			c1 = getCornerPos(center,length,0);
			result = 0.5f*(c0+c1);
			break;
		case 4:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,2);
			result = 0.5f*(c0+c1);
			break;
		case 5:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,4);
			result = 0.5f*(c0+c1);
			break;
		case 6:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,5);
			result = 0.5f*(c0+c1);
			break;
		case 7:
			c0 = getCornerPos(center,length,1);
			c1 = getCornerPos(center,length,5);
			result = 0.5f*(c0+c1);
			break;
		case 8:
			c0 = getCornerPos(center,length,1);
			c1 = getCornerPos(center,length,6);
			result = 0.5f*(c0+c1);
			break;
		case 9:
			c0 = getCornerPos(center,length,2);
			c1 = getCornerPos(center,length,6);
			result = 0.5f*(c0+c1);
			break;
		case 10:
			c0 = getCornerPos(center,length,2);
			c1 = getCornerPos(center,length,7);
			result = 0.5f*(c0+c1);
			break;
		case 11:
			c0 = getCornerPos(center,length,3);
			c1 = getCornerPos(center,length,7);
			result = 0.5f*(c0+c1);
			break;
		case 12:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,7);
			result = 0.5f*(c0+c1);
			break;
		case 13:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,6);
			result = 0.5f*(c0+c1);
			break;
		case 14:
			c0 = getCornerPos(center,length,4);
			c1 = getCornerPos(center,length,5);
			result = 0.5f*(c0+c1);
			break;
		case 15:
			c0 = getCornerPos(center,length,5);
			c1 = getCornerPos(center,length,6);
			result = 0.5f*(c0+c1);
			break;
		case 16:
			c0 = getCornerPos(center,length,6);
			c1 = getCornerPos(center,length,7);
			result = 0.5f*(c0+c1);
			break;
		case 17:
			c0 = getCornerPos(center,length,0);
			c1 = getCornerPos(center,length,4);
			result = 0.5f*(c0+c1);
			break;
		case 18:
			c0 = getCornerPos(center,length,4);
			c1 = getCornerPos(center,length,6);
			result = 0.5f*(c0+c1);
			break;
		default:
			Debug.LogError("Invalid corner number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3[] GetMidPointsPos(Vector3 center, float length)
	{
		Vector3[] results = new Vector3[19];
		for (byte i = 0; i < 19; i++) {
			results[i] = GetMidPointPos(center,length,i);
		}
		return results;
	}
}