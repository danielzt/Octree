//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading;
using UnityEngine;
using NuHash.UsefulUtilities;
public class Octree
{
	public OctreeData data;
	public byte[] baseTrace;
	public Vector3 position;
	public float boxLength;
	List<List<byte>> leaves = new List<List<byte>>(100000000);
	Int64 queuedItems;
	Stack<ThreadObject> queuedLeaves = new Stack<ThreadObject>(10000000);
	readonly object _lock = new object();

	private struct ThreadObject{
		public List<byte> trace;
		public float length;
		public Vector3 pos;
	}

//	public bool IsSplit {
//		get{return (child != null);}
//	}
//	
//	public Octree Child(int idx) {
//		if(idx>7 || idx<0 || !this.IsSplit)
//		{
//			Debug.LogError("No children available or index is out of range");
//			return null;
//		}
//		return child[idx];
//	}
	
	public Octree (OctreeData data,Vector3 position,float length,byte[] trace)
	{
		this.baseTrace = trace;
		this.position = position;
		this.data = data;
		this.boxLength = length;
	}

	public void Split()
	{

			float newLength = boxLength/2;
			for (byte i = 0; i < 8; i++) {
				List<byte> trace = new List<byte>{0,i};
				ThreadObject tO = new ThreadObject(){
					trace = trace,
					length = newLength,
					pos = GetChildPos(position,boxLength,i),
				};
				queuedLeaves.Push(tO);
				//ThreadPool.QueueUserWorkItem(new WaitCallback(SplitThread));
			}
			Thread thread = new Thread(new ThreadStart(()=>SplitThread(0)));
			thread.Start();
			Thread thread1 = new Thread(new ThreadStart(()=>SplitThread(1)));
			thread1.Start();
			Thread thread2 = new Thread(new ThreadStart(()=>SplitThread(2)));
			thread2.Start();
			Thread thread3 = new Thread(new ThreadStart(()=>SplitThread(3)));
			thread3.Start();
			Thread thread4 = new Thread(new ThreadStart(()=>SplitThread(4)));
			thread4.Start();
			Thread thread5 = new Thread(new ThreadStart(()=>SplitThread(5)));
			thread5.Start();
			Thread thread6 = new Thread(new ThreadStart(()=>SplitThread(6)));
			thread6.Start();
			Thread thread7 = new Thread(new ThreadStart(()=>SplitThread(7)));
			thread7.Start();
//			SplitThread(0);

	}

	private void SplitThread(int tNum=1)//byte[] trace,ref float length)
	{
		int threadNum = tNum;
		ThreadObject a;
		lock(_lock){
			a = queuedLeaves.Pop();
		}
		while(true){
			var trace = a.trace;
			float length = a.length;
			Vector3 cellPos = a.pos;
			if(data.splitPolicy(cellPos,length,trace, threadNum))
			{
				//List<byte> newTrace = new List<byte>(trace);
				//newTrace.Add(0);
				int endPos = trace.Count;
				trace.Add(7);
				float newLength = length/2;
				for (byte i = 0; i < 7; i++) {
					List<byte> newTrace = new List<byte>(trace);
					newTrace[endPos] = i;
					ThreadObject tO = new ThreadObject(){
						trace = newTrace,
						length = newLength,
						pos = GetChildPos(cellPos,length,i)
					};
					lock(_lock){
						queuedLeaves.Push(tO);
					}
				}
				a.length = newLength;
				a.pos = GetChildPos(cellPos,length,7);
				lock(_lock){
					queuedLeaves.Push(a);
				}
				
			}else{
				lock(_lock){
					leaves.Add(trace);
					//Debug.Log (trace.Count-1);
				}
			}
			lock(_lock){
				if(queuedLeaves.Count <1)
					break;
				a = queuedLeaves.Pop();
			}
		}
		Debug.Log("Split complete");
		Debug.Log(leaves.Count+" leaves.");
	}

	public static UInt64 ChildTrace(UInt64 trace){
		byte level = TraceToLevel(trace);
		return LevelToTrace((byte)(level+1))+8*(trace-LevelToTrace(level));
	}

	public static UInt64 ChildTrace(UInt64 trace,byte level){
		return LevelToTrace((byte)(level+1))+8*(trace-LevelToTrace(level));
	}
	
	public static byte TraceToLevel(UInt64 trace)
	{
		return (byte)(NMath.Log2_64((7*trace/8)+1)/3);
	}

	public static UInt64 LevelToTrace(byte level)
	{
		return (UInt64)(1<<(3*level) - 1)*8/7;
	}

	public Vector3 TraceToPosition(byte[] trace)
	{
		Vector3 pos = position;
		float len = boxLength;
		for (int i = 1; i < trace.Length; i++) {
			pos = GetChildPos(pos,len,trace[i]);
			len = len/2;
		}
		return pos;
	}

	public Vector3 TraceToPosition(UInt64 trace)
	{
		if(trace==0)
			return position;
		UInt64 level = NMath.Log2_64(7*trace/8+1)/3ul -1ul;
		Vector3 pos = position;
		float len = boxLength;
		UInt64 nCells = NMath.IntPow(8,level);
		while(level>0){
			UInt64 rPos = trace - nCells/8;
			byte childNum = (byte)(8*rPos/nCells);
			pos = GetChildPos(pos,len,childNum);
			len = len/2;
			nCells = nCells/8;
			level--;
		}
		return pos;
	}

	public static Vector3 GetChildPos(Vector3 oldCenter, float oldLength, byte childNum)
	{
		Vector3 result;
		Vector3 diff;
		switch(childNum)
		{
		case 0:
			diff = -0.25f*new Vector3(oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 1:
			diff = 0.25f*new Vector3(oldLength,-oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 2:
			diff = 0.25f*new Vector3(oldLength,-oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 3:
			diff = 0.25f*new Vector3(-oldLength,-oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 4:
			diff = 0.25f*new Vector3(-oldLength,oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 5:
			diff = 0.25f*new Vector3(oldLength,oldLength,-oldLength);
			result = oldCenter + diff;
			break;
		case 6:
			diff = 0.25f*new Vector3(oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		case 7:
			diff = 0.25f*new Vector3(-oldLength,oldLength,oldLength);
			result = oldCenter + diff;
			break;
		default:
			Debug.LogError("Invalid child number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3 GetCornerPos(Vector3 center, float length, byte cornerNum)
	{
		Vector3 result;
		Vector3 diff;
		switch(cornerNum)
		{
		case 0:
			diff = -0.5f*new Vector3(length,length,length);
			result = center + diff;
			break;
		case 1:
			diff = 0.5f*new Vector3(length,-length,-length);
			result = center + diff;
			break;
		case 2:
			diff = 0.5f*new Vector3(length,-length,length);
			result = center + diff;
			break;
		case 3:
			diff = 0.5f*new Vector3(-length,-length,length);
			result = center + diff;
			break;
		case 4:
			diff = 0.5f*new Vector3(-length,length,-length);
			result = center + diff;
			break;
		case 5:
			diff = 0.5f*new Vector3(length,length,-length);
			result = center + diff;
			break;
		case 6:
			diff = 0.5f*new Vector3(length,length,length);
			result = center + diff;
			break;
		case 7:
			diff = 0.5f*new Vector3(-length,length,length);
			result = center + diff;
			break;
		default:
			Debug.LogError("Invalid corner number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3[] GetCornersPos(Vector3 center, float length)
	{
		Vector3[] results = new Vector3[8];
		for (byte i = 0; i < 8; i++) {
			results[i] = GetCornerPos(center,length,i);
		}
		return results;
	}

	public static void GetCornersPos(Vector3 center, float length, ref Vector3[] results)
	{
		if(!(results.Length >= 8)){
			throw new IndexOutOfRangeException("Number of elements in results array is not enough to accomodate positions");
		}
		for (byte i = 0; i < 8; i++) {
			results[i] = GetCornerPos(center,length,i);
		}
		return;
	}

	
	public static Vector3 GetMidPointPos(Vector3 center, float length, byte posNum)
	{
		Vector3 result,diff;
		switch(posNum)
		{
		case 0:
			diff = new Vector3(0,-length,-length);
			result = center + 0.5f*diff;
			break;
		case 1:
			diff = new Vector3(length,-length,0);
			result = center + 0.5f*diff;
			break;
		case 2:
			diff = new Vector3(0,-length,length);
			result = center + 0.5f*diff;
			break;
		case 3:
			diff = new Vector3(-length,-length,0);
			result = center + 0.5f*diff;
			break;
		case 4:
			diff = new Vector3(0,-length,0);
			result = center + 0.5f*diff;
			break;
		case 5:
			diff = new Vector3(-length,0,-length);
			result = center + 0.5f*diff;
			break;
		case 6:
			diff = new Vector3(0,0,-length);
			result = center + 0.5f*diff;
			break;
		case 7:
			diff = new Vector3(length,0,-length);
			result = center + 0.5f*diff;
			break;
		case 8:
			diff = new Vector3(length,0,0);
			result = center + 0.5f*diff;
			break;
		case 9:
			diff = new Vector3(length,0,length);
			result = center + 0.5f*diff;
			break;
		case 10:
			diff = new Vector3(0,0,length);
			result = center + 0.5f*diff;
			break;
		case 11:
			diff = new Vector3(-length,0,length);
			result = center + 0.5f*diff;
			break;
		case 12:
			diff = new Vector3(-length,0,0);
			result = center + 0.5f*diff;
			break;
		case 13:
			result = center;
			break;
		case 14:
			diff = new Vector3(0,length,-length);
			result = center + 0.5f*diff;
			break;
		case 15:
			diff = new Vector3(length,0,0);
			result = center + 0.5f*diff;
			break;
		case 16:
			diff = new Vector3(0,length,length);
			result = center + 0.5f*diff;
			break;
		case 17:
			diff = new Vector3(-length,length,0);
			result = center + 0.5f*diff;
			break;
		case 18:
			diff = new Vector3(0,length,0);
			result = center + 0.5f*diff;
			break;
		default:
			Debug.LogError("Invalid corner number");
			result = Vector3.zero;
			break;
		}
		return result;
	}

	public static Vector3[] GetMidPointsPos(Vector3 center, float length)
	{
		Vector3[] results = new Vector3[19];
		for (byte i = 0; i < 19; i++) {
			results[i] = GetMidPointPos(center,length,i);
		}
		return results;
	}

	public static void GetMidPointsPos(Vector3 center, float length,ref Vector3[] results)
	{
		if(!(results.Length >= 19)){
			throw new IndexOutOfRangeException("Number of elements in results array is not enough to accomodate positions");
		}
		for (byte i = 0; i < 19; i++) {
			results[i] = GetMidPointPos(center,length,i);
		}

		return;
	}
	
}